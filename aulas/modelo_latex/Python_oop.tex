\documentclass{beamer}

\usepackage{aula}

\title{Python orientado a objetos}
\date{\today}

\begin{document}
  
\input{capa}

\begin{frame}{Paradigmas de programação em Python}
  
  Python suporta múltiplos paradigmas:
  \begin{itemize}
    \item Programação funcional
    \item Programação orientada a objetos (OO)
  \end{itemize}
  
  \vspace{0.3cm}
  
  \textbf{Funcional}
  \begin{itemize}
    \item Ênfase em funções
    \item Dados passados como argumentos
    \item Simples para tarefas pequenas
    \item Um comportamento é aplicado a toda uma relação de objetos.
    \item Muito utilizada em simulações e jogos quando grandes quantidades de entidades devem ser atualizadas frequentemente (ECS). 
  \end{itemize}
  
  \vspace{0.2cm}
  
  \textbf{Orientado a Objetos}
  \begin{itemize}
    \item Dados + comportamento juntos
    \item Modela entidades do mundo real
    \item Facilita manutenção e reutilização
  \end{itemize}
  
\end{frame}

\begin{frame}{Por que usar Orientação a Objetos?}
  
  \textbf{Principais vantagens:}
  \begin{itemize}
    \item Organização do código em entidades
    \item Reutilização por meio de classes
    \item Facilita leitura e manutenção
    \item Escala melhor para sistemas grandes
  \end{itemize}
  
  \vspace{0.3cm}
  
  \textbf{Quando OO é mais indicada:}
  \begin{itemize}
    \item Projetos grandes
    \item Sistemas com múltiplas responsabilidades
    \item Entidades com comportamentos variados
    \item Modelagem de objetos reais (usuários, mapas, sensores)
  \end{itemize}
  
\end{frame}

\begin{frame}[fragile]{Exemplo Funcional — LineString}
  Salvar em operacoes/comprimentos.py
  \begin{minted}{python}
import math

def comprimento_linha(coords):
  comprimento = 0.0
  for i in range(len(coords) - 1):
    x1, y1 = coords[i]
    x2, y2 = coords[i + 1]
    comprimento += math.dist((x1, y1), (x2, y2))
    return comprimento
    
#só entra no if se este arquivo não for importado por outro.
if __name__ = ="__main__":
    linha = [(0, 0), (3, 4), (6, 4)]
    comp = comprimento_linha(linha)
\end{minted}
  
  \vspace{0.3cm}
  
  \textbf{Características:}
  \begin{itemize}
    \item Dados são estruturas externas
    \item Funções operam sobre listas de coordenadas
    \item Pouca semântica explícita
  \end{itemize}
  
\end{frame}

\begin{frame}[fragile]{Exemplo Orientado a Objetos — LineString}
    
    \begin{minted}{python}
import math
class LineString:
    def __init__(self, coords):
        self.coords = coords

    def comprimento(self):
        comprimento = 0.0
        for i in range(len(self.coords) - 1):
        p1 = self.coords[i]
        p2 = self.coords[i + 1]
        comprimento += math.dist(p1, p2)
        return comprimento

if __name__ == "__main__":
    linha = LineString([(0, 0), (3, 4), (6, 4)])
    comp = linha.comprimento()
    \end{minted}
    
    \vspace{0.3cm}
    
    \textbf{Vantagem:}
    \begin{itemize}
        \item Geometria encapsula dados e operações
    \end{itemize}
    
\end{frame}

\begin{frame}[fragile]{Módulos e pacotes em Python}
  
  \textbf{Estrutura de arquivos:}
  
  \begin{minted}{text}
projeto/
  main.py
  operacoes/
    __init__.py
    comprimentos.py
  \end{minted}
  
  \vspace{0.3cm}
  
  \textbf{Importação:}
  
  \begin{minted}{python}
from operacoes import comprimentos #importa todo o módulo
from operacoes.comprimentos import #importa todo o módulo
  \end{minted}
  
  \vspace{0.2cm}
  
  \textbf{Benefício:}
  \begin{itemize}
    \item Código organizado e reutilizável
    \item O que aconteceu com o escopo do if \_\_name\_\_ == "\_\_main\_\_":?
  \end{itemize}
  
\end{frame}

\begin{frame}[fragile]{Declaração de classes em Python}
  
  \begin{minted}{python}
class NomeDaClasse:
  def __init__(self, parametro):
    self.atributo = parametro
    
  def metodo(self):
    print(self.atributo)
  \end{minted}
  
  \vspace{0.3cm}
  
  \textbf{Elementos principais:}
  \begin{itemize}
    \item \texttt{class}: define uma classe
    \item \texttt{self}: referência ao objeto
    \item Métodos: funções da classe
  \end{itemize}
  \textbf{Função do \texttt{\_\_init\_\_}:}
  \begin{itemize}
    \item Executado na criação do objeto
    \item Inicializa atributos
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Instanciação de objetos}
  
  \begin{minted}{python}
class Ponto:
  def __init__(self, x, y):
    self.x = x
    self.y = y

p1 = Ponto(10,20)
p2 = Ponto(-10,10) 

print(p1) #<\_\_main\_\_.Ponto object at 0x71e2a65bcdd0>
print(p2) #<\_\_main\_\_.Ponto object at 0x71e2a642c770>

print(p2.x, p2.y) #-10 10
  \end{minted}
  
  \vspace{0.3cm}
  
  \textbf{Observação:}
  \begin{itemize}
    \item Cada objeto tem seu próprio estado
  \end{itemize}
  
\end{frame}


\begin{frame}[fragile]{@dataclass}
  
  \begin{minted}{python}
from dataclasses import dataclass

@dataclass
class Ponto:
  x: float
  y: float
  
p1 = Ponto(10,20)
p2 = Ponto(-10,10)

print(p1) # Ponto(x=10, y=20)
print(p2) # Ponto(x=-10, y=10)
  \end{minted}
  
  \vspace{0.3cm}
  
  \textbf{Vantagens:}
  \begin{itemize}
    \item Menos código repetitivo
    \item \texttt{\_\_init\_\_}, \texttt{\_\_repr\_\_} automáticos
    \item Ideal para classes de dados
  \end{itemize}
  
\end{frame}

\begin{frame}[fragile]{@dataclass}
\textbf{Orientação a objetos com \texttt{@dataclass}}

\begin{minted}{python}
import math
from dataclasses import dataclass

@dataclass
class LineString:
  coords: list[tuple[float, float]]
  
  def comprimento(self) -> float:
    comprimento = 0.0
    for i in range(len(self.coords) - 1):
      p1 = self.coords[i]
      p2 = self.coords[i + 1]
      comprimento += math.dist(p1, p2)
      return comprimento
    
linha = LineString([(0, 0), (3, 4), (6, 4)])
comp = linha.comprimento()
\end{minted}

\textbf{Vantagens:}
\begin{itemize}
  \item Menos código boilerplate
  \item Classe expressiva
\end{itemize}
\end{frame}

\begin{frame}{Open Geospatial Consortium (OGC) - Simple features access}
Especificação: \url{https://www.ogc.org/publications/standard/sfa/}
\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{Python_oop/sfs}
\end{figure}
\end{frame}


\begin{frame}[fragile]{OGC SFS — Herança de classes}
  
  \textbf{OGC Simple Feature Specification (SFS)}
  
  \vspace{0.3cm}
  
  No OGC SFS:
  \begin{itemize}
    \item \texttt{Geometry} é a classe base
    \item Tipos geométricos específicos herdam de \texttt{Geometry}
  \end{itemize}
  
  \vspace{0.3cm}
  
  \textbf{Exemplo em Python:}
  
  \begin{minted}{python}
class Geometry:
  def __init__(self, pontos):
    self.pontos = pontos
    
  def area(self) -> float:
    raise NotImplementedError
  \end{minted}
  
  \vspace{0.3cm}
  
  \textbf{Conceito-chave:}
  \begin{itemize}
    \item Classes filhas herdam interface e comportamento
  \end{itemize}
  
\end{frame}

\begin{frame}{OGC SFS — Diagrama de classes (simplificado)}
  
  
  \begin{figure}
    \centering
    \includegraphics[width=0.4\textwidth]{Python_oop/heranca}
  \end{figure}
  \vspace{0.3cm}
  
  \textbf{Objetivo do diagrama:}
  \begin{itemize}
    \item Visualizar herança
    \item Relacionar código com modelo conceitual
  \end{itemize}
  
\end{frame}

\begin{frame}[fragile]{OGC SFS — Classes derivadas}
  
  \begin{columns}[t]
    
    % -------- LineString --------
    \begin{column}{0.48\textwidth}
      \textbf{LineString}
      
      \vspace{0.2cm}
      
      \begin{minted}[tabsize=2]{python}
class LineString(Geometry):
  # Método herdado:
  # __init__(self, pontos)

  def area(self) -> float:
    return 0.0
      \end{minted}
      
      \begin{itemize}
        \item Geometria unidimensional
        \item Não ocupa área
      \end{itemize}
    \end{column}
    
    % -------- Polygon --------
    \begin{column}{0.48\textwidth}
      \textbf{Polygon}
      
      \vspace{0.2cm}
      
      \begin{minted}[tabsize=2]{python}
class Polygon(Geometry):
  # Método herdado:
  # __init__(self, pontos)

  def area(self) -> float:
    area = 0.0
    n = len(self.pontos)
    for i in range(n):
      x1,y1=self.pontos[i]
      x2,y2=self.pontos[(i+1)%n]
      area += x1*y2 - x2*y1
    return abs(area) / 2.0
      \end{minted}
      
      \begin{itemize}
        \item Geometria bidimensional
        \item Implementa cálculo real de área
      \end{itemize}
    \end{column}
    
  \end{columns}
  
  
  \textbf{Mensagem-chave:}
  \begin{itemize}
    \item Mesmo método
    \item Resultados semanticamente distintos
  \end{itemize}
  
\end{frame}
\begin{frame}[fragile]{Polimorfismo com OGC SFS}
  
  \begin{minted}{python}
def imprimir_area(geom: Geometry):
  print(f"Área = {geom.area()}")
  \end{minted}
  
  \vspace{0.3cm}
  
  \begin{minted}{python}
l = LineString([(0,0), (1,1)])
p = Polygon([(0,0), (1,0), (1,1), (0,1)])

imprimir_area(l)
imprimir_area(p)
  \end{minted}
  
  \vspace{0.3cm}
  
  \textbf{Resultado:}
  \begin{itemize}
    \item Mesmo código
    \item Comportamento depende da classe concreta
  \end{itemize}
  
\end{frame}


\begin{frame}[fragile]{Shapely - Declaração de geometrias para GeoPandas}
    \textbf{Shapely} modela geometrias vetoriais segundo o padrão OGC Simple Features.
    \begin{columns}[t]
        \begin{column}[t]{0.6\textwidth}
            \begin{minted}{python}
import shapely

geom_P = shapely.Point(10,20)
# <POINT (10 20)>

geom_L = shapely.LineString(
    [(10,20), (10,30), (10,35)]
)
# <LINESTRING (10 20, 10 30, 10 35)>

geom_A = shapely.Polygon(
    [(10,20), (10,30), (10,35)]
)
#<POLYGON ((10 20, 10 30, 10 35, 10 20))>
            \end{minted}
        \end{column}
        
        \begin{column}[t]{0.4\textwidth}
            \begin{figure}
                \centering
                \includegraphics[width=\textwidth]{Python_oop/shapely}
            \end{figure}
        \end{column}
    \end{columns}   
    \textbf{Observação:}
    \begin{itemize}
        \item Todas herdam de uma classe base geométrica
        \item Compartilham operações como: area, length, intersects
    \end{itemize}
\end{frame}


\begin{frame}{Pandas - Principais conceitos}
    
    \textbf{Pandas} é uma biblioteca para manipulação e análise de dados tabulares (planilhas ou tabelas).
    
    \vspace{0.4cm}
    
    Estruturas fundamentais:
    
    \begin{itemize}
        \item \textbf{Series} → vetor unidimensional
        \item \textbf{DataFrame} → tabela bidimensional (linhas × colunas)
    \end{itemize}
    
    \vspace{0.4cm}
    
    Conceitos importantes:
    
    \begin{itemize}
        \item Índice (index)
        \item Seleção: \texttt{loc}, \texttt{iloc}
        \item Operações vetorizadas
        \item GroupBy e agregações
        \item Integração com NumPy
    \end{itemize}
    
    \vspace{0.4cm}
    
    Modelo mental:
    
    \begin{center}
        Tabela relacional em memória
    \end{center}
    
\end{frame}

\begin{frame}[fragile]{Pandas - Operações em planilhas}
    \begin{columns}[t]
        \begin{column}[t]{0.6\textwidth}
    
            \begin{minted}{python}
import pandas as pd

# Ler arquivo CSV
df = pd.read_csv("dados.csv")

# Criar nova coluna (operação vetorizada)
df["soma"] = df["attr1"] + df["attr2"]

print(df)
            \end{minted}
        \end{column}
        \begin{column}[t]{0.40\textwidth}
            \textbf{CSV exemplo:}
        
            \begin{verbatim}
attr1,attr2
10,5
7,3
            \end{verbatim}
        \end{column}
    \end{columns}
    \textbf{Observação:}
    
    Operações são vetorizadas → não é necessário loop explícito.\\
    Outras opções úteis: 
    \begin{itemize}
        \item read\_excel() 
        \item read\_parquet()
    \end{itemize}
    
\end{frame}

\begin{frame}{GeoPandas}
    
    \textbf{GeoPandas} estende o Pandas para dados espaciais vetoriais.
    
    \vspace{0.4cm}
    
    Principais conceitos:
    
    \begin{itemize}
        \item GeoDataFrame (extensão do DataFrame)
        \item Coluna especial: \texttt{geometry}
        \item Integração com Shapely
        \item Uso de CRS (Coordinate Reference System)
    \end{itemize}
    
    \vspace{0.4cm}
    
    Stack típica:
    \begin{itemize}
        \item Pandas (estrutura tabular)
        \item Shapely (geometria)
        \item Fiona / Pyogrio (leitura/escrita)
        \item PROJ (sistemas de referência)
    \end{itemize}
    
\end{frame}

\begin{frame}{GeoPandas - Estrutura Fundamental}
    
    \textbf{GeoDataFrame = DataFrame + geometria}
    
    \vspace{0.4cm}
    
    Componentes principais:
    
    \begin{itemize}
        \item Atributos tabulares
        \item Coluna geometry (Point, LineString, Polygon)
        \item CRS associado
    \end{itemize}
    
    \vspace{0.4cm}
    
    Operações comuns:
    
    \begin{itemize}
        \item \texttt{gdf.plot()}
        \item \texttt{gdf.to\_crs()}
        \item \texttt{gdf.buffer()}
        \item \texttt{gdf.overlay()}
    \end{itemize}
    
\end{frame}

\begin{frame}[fragile]{GeoPandas - Diagrama de Classes}
    \begin{columns}[t]
        \begin{column}[t]{0.48\textwidth}
            \textbf{Interpretação:}
            
            \begin{itemize}
                \item Linhas → feições (features)
                \item Colunas → atributos
                \item Uma coluna especial: \texttt{geometry}
                \item GeoDataFrame herda todas as operações tabulares do DataFrame
            \end{itemize}
        \end{column}
        \begin{column}[t]{0.48\textwidth}
            \begin{figure}
                \centering
                \includegraphics[width=0.5\textwidth]{Python_oop/geopandas}
            \end{figure}
        \end{column}
    \end{columns} 

    \vspace{0.3cm}
    
    
    
\end{frame}

\begin{frame}[fragile]{Exemplo — CSV com lat, lon, height}
    

    
    \begin{columns}[t]
        \begin{column}[t]{0.6\textwidth}
            \begin{minted}{python}
import pandas as pd
import geopandas as gpd
from shapely.geometry import Point

# Ler CSV
df = pd.read_csv("pontos.csv")

# Criar GeoDataFrame
gdf = gpd.GeoDataFrame(df,
    geometry=gpd.points_from_xy(
    df.lon, df.lat),
    crs="EPSG:4326"
)

print(gdf.head())
            \end{minted}
        \end{column}
        \begin{column}[t]{0.4\textwidth}
            \textbf{CSV exemplo:}
        
            \begin{verbatim}
lat,lon,height
-15.78,-47.93,1100
-22.90,-43.20,5
            \end{verbatim}
        \end{column}
    \end{columns}   
    

    
\end{frame}

\begin{frame}{Conceitos Espaciais Importantes}
    
    \textbf{1. CRS}
    \begin{itemize}
        \item Define sistema de coordenadas
        \item Reprojeção via \texttt{to\_crs()}
    \end{itemize}
    
    \vspace{0.3cm}
    
    \textbf{2. Operações Espaciais}
    \begin{itemize}
        \item Buffer
        \item Interseção
        \item Spatial Join
    \end{itemize}
    
    \vspace{0.3cm}
    
    \textbf{3. Integração}
    \begin{itemize}
        \item Funciona naturalmente com Pandas
        \item Exporta para Shapefile, GeoPackage, Parquet
    \end{itemize}
    
    \vspace{0.3cm}
    
    GeoPandas é ideal para:
    \begin{itemize}
        \item Análise exploratória espacial
        \item Prototipagem rápida
        \item Ciência de dados geoespacial
    \end{itemize}
    
\end{frame}


\begin{frame}[fragile]{Exercícios - Downloader}
  \begin{columns}[t]
    \begin{column}[t]{0.6\textwidth}
        \begin{itemize}
          \item Implementem uma classe que baixe dados de um servidor.
          \item Para criar um objeto “Downloader” devem ser passados o endereço de download e uma pasta de destino. 
        \end{itemize}
    \end{column}
    
    \begin{column}[t]{0.4\textwidth}
      \colimage{Python_oop/downloader}

    \end{column}
  \end{columns}
    \href{https://www.geeksforgeeks.org/how-to-download-files-from-urls-with-python/}{Link da dica}\\
    O endereço de uma folha no geoftp do IBGE é: \\
    \url{https://geoftp.ibge.gov.br/cartas_e_mapas/folhas_topograficas/vetoriais/escala_1000mil/shapefile/g04_na19.zip} \\
    Exemplo:
    
    \begin{minted}[fontsize=\scriptsize]{python}
parte1 = ”https://geoftp.ibge.gov.br/cartas_e_mapas/folhas_topograficas/”
parte2 = f"vetoriais/escala_1000mil/shapefile/{name}.zip"
server_url_format = parte1 + parte2
    \end{minted}
    
\end{frame}

\begin{frame}[fragile]{Exercícios - Downloader}
    \begin{minted}[fontsize=\scriptsize]{python}
import requests, os 

class Downloader:
    def __init__(self, server_url_format, destination_folder):
        # Inicialização dos atributos da classe
        self.server_url_format = server_url_format
        self.destination_folder = destination_folder
        #verifica se a pasta existe, se não existe, cria.
        os.makedirs(self.destination_folder, exist_ok=True)

    def download_file(self, name):
        # Esta não é a melhor forma de fazer isso. É um exemplo.
        url = self.server_url_format.format(name)
        response = requests.get(url)
        file_Path = f'{self.destination_folder}/{name}.zip'
    
        if response.status_code == 200:
            with open(file_Path, 'wb') as file:
                file.write(response.content)
                print('File downloaded successfully')
            else:
                print('Failed to download file')
    \end{minted}

\end{frame}


\begin{frame}[fragile]{Exercícios - Downloader}
    \textbf{Utilizando a classe:}
    \begin{minted}[fontsize=\scriptsize]{python}
# Esta parte do código só será executada se este for o arquivo principal.
# Ou seja: python downloader.py
if __name__=="__main__": 
    # Cria o objeto da classe Downloader
    obj_teste = Downloader( \
    "https://geoftp.ibge.gov.br/cartas_e_mapas/folhas_topograficas/vetoriais/escala_1000mil/shapefile/{}.zip", \
    "/home/mauricio/Desktop/progcart/aulas" )
    
    # Lista os atributos e métodos do objeto.
    print(dir(obj_teste))
    
    # Chama uma função do objeto criado.
    obj_teste.download_file("g04_na19")
    \end{minted}

\end{frame}

\begin{frame}[fragile]{Mais exercícios}
    Exercícios para o pessoal que quiser praticar orientação a objetos:
    
    \url{https://www.w3resource.com/python-exercises/oop/index.php}
\end{frame}

\end{document}
